# Auto-Push Commit Message
auto_add_commit_push () {
  current_dir="$PWD"
  if [[ "$current_dir" == *"organize"* || "$current_dir" == *"cw-notes"* || "$current_dir" == *"pensieve"* ]]; then
    date_and_time=$(date '+%Y-%m-%d %H:%M:%S')
    git add -A && git commit -m "pushed via script $date_and_time" && git push
  else
    echo "Whatâ€™s the matter with you?!"
  fi
}

# Check if command is installed
check_command() {
  local command_to_check="$1"
  if ! command -v "$command_to_check" > /dev/null 2>&1; then
    echo "Error: $command_to_check is not installed. Exiting."
    return 1
  fi
}

# Select ghq location with fzf
fhq () {
  check_command fzf || return 1
  if whence -p ghq > /dev/null 2>&1; then
    cd $(ghq list --full-path | fzf)
  else
    cd $(find ~/ghq -maxdepth 3 -mindepth 3 -type d  | fzf)
  fi
}


# Change directory to the root of the git repo
gr () {
  local git_dir
  git_dir=$(git rev-parse --show-toplevel 2>/dev/null)
  
  if [[ -n "$git_dir" ]]; then
    cd "$git_dir"
  else
    echo "Not inside a Git repository."
  fi
}

# create a new note in the orgnizer directory
function n() {
    local note_dir="$ORG_DIRECTORY" # assumes ORG_DIRECTORY is set
    local timestamp=$(date +'%y%m%d')
    local note_number=1
    # Find the highest existing note number
    while [[ -e "$note_dir/${timestamp}-$(printf '%03d' $note_number)-note.md" ]]; do
        ((note_number++))
    done
    local note_file="${note_dir}/${timestamp}-$(printf '%03d' $note_number)-note.md"
    nvim "$note_file"
    echo "Note saved as $note_file"
}

# Exa Functions
ll () {
  if command -v eza > /dev/null 2>&1 ; then
    eza --long --icons --git --group "$@"
  elif command -v exa > /dev/null 2>&1 ; then
    exa --long --icons --git --group "$@"
  else
    ls -l "$@"
  fi
}
xt () {
  if command -v eza > /dev/null 2>&1 ; then
    eza --long --icons --git --group --tree --git-ignore "$@"
  elif command -v exa > /dev/null 2>&1 ; then
    exa --long --icons --git --group --tree --git-ignore "$@"
  else
    echo "Exa is not installed!"
  fi
}

# fff
f() {
  check_command fff || return 1
  fff "$@"
  cd "$(cat "$HOME/.cache/fff/.fff_d")"
}

### ghq
ghq() {
  if whence -p ghq > /dev/null 2>&1 ; then
    command ghq "$@"
  else
    ghqShellVersion "$@"
  fi
}

ghqShellVersion() {
  # Function to display usage instructions
  usage() {
      echo "Usage: ghq get <repository_url>"
      echo "       ghq list"
  }

  get_repo() {
    repo_url=$1
    if [[ $repo_url == *@* ]]; then
        # SSH format (with or without .git)
        domain=$(echo "$repo_url" | awk -F'[@:/]' '{print $2}')
        user=$(echo "$repo_url" | awk -F'[@:/]' '{print $3}')
        repo=$(echo "$repo_url" | awk -F'[@:/]' '{print $4}' | sed 's/\.git$//')
    else
        # HTTPS format (with or without .git)
        domain=$(echo "$repo_url" | awk -F/ '{print $(NF-2)}')
        user=$(echo "$repo_url" | awk -F/ '{print $(NF-1)}')
        repo=$(echo "$repo_url" | awk -F/ '{print $(NF)}' | sed 's/\.git$//')
    fi
    if [[ -n "$domain" && -n "$user" && -n "$repo" ]]; then
      target_dir="$HOME/ghq/$domain/$user/$repo"
      mkdir -p "$target_dir"
      git clone $repo_url $target_dir
    else
      echo "Error: Invalid repository URL format."
      usage
      return 1
    fi
  }

  # Check if the first argument is 'get'
  if [[ $1 == "get" && $# -eq 2 ]]; then
      get_repo $2
  elif [[ $1 == "list" ]]; then
      find $HOME/ghq -maxdepth 3 -mindepth 3 -type d 
  else
      usage
      return 1
  fi
}

# qlmanage
grab () {
  check_command pbcopy || return 1
  pwd | pbcopy
}
drop () {
  check_command pbpaste || return 1
  cd $(pbpaste)
}
